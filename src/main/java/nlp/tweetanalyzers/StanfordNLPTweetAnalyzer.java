package nlp.tweetanalyzers;

import edu.stanford.nlp.pipeline.CoreDocument;
import edu.stanford.nlp.pipeline.CoreSentence;
import edu.stanford.nlp.pipeline.SentimentAnnotator;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;
import nlp.AnalyzedTweet;
import nlp.SanitizedTweet;

import javax.swing.text.html.HTMLDocument;
import java.io.File;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;

public class StanfordNLPTweetAnalyzer implements OverallSentimentAnalyzer, SentenceSentimentAnalyzer {

    private StanfordCoreNLP pipeline;
    private Properties properties;

    private static StanfordNLPTweetAnalyzer stanfordNLPTweetAnalyzer = null;

    /**
     * Singleton design pattern
     * @return
     */
    public static StanfordNLPTweetAnalyzer getInstance(){
        System.out.println("get instance");
        if(stanfordNLPTweetAnalyzer == null)
            stanfordNLPTweetAnalyzer = new StanfordNLPTweetAnalyzer();
        return stanfordNLPTweetAnalyzer;
    }

    /**
     * Private Constructor that sets up the nlp pipeline. Uses the better model if the file exists,
     * otherwise uses the default model.
     */
    private StanfordNLPTweetAnalyzer(){
        properties = new Properties();
        properties.setProperty("annotators", "tokenize,ssplit,pos,parse, sentiment");
        properties.setProperty("ner.useSUTime", "false");
        properties.put("threads", "12");
        boolean useDefaultModel = false;
        String betterModel = "stanford-nlp-models/gate-EN-twitter.model";
        File file = new File("stanford-nlp-models/gate-EN-twitter.model");
        if(file.exists() && !file.isDirectory())
            useDefaultModel = true;
        if(useDefaultModel)
            properties.setProperty("pos.model",betterModel);

        pipeline = new StanfordCoreNLP(properties);
    }
    @Override
    public AnalyzedTweet analyzeSanitizedTweetSentiment(SanitizedTweet sanitizedTweet) {
        AnalyzedTweet analyzedTweet = new AnalyzedTweet(sanitizedTweet);
        CoreDocument document = new CoreDocument(analyzedTweet.getSanitizedText());
        pipeline.annotate(document);

        List<CoreSentence> sentences = document.sentences();
        int len = sentences.size();

        String[] strSentences = new String[len];
        int[] sentenceSentiments = new int[len];

        Iterator<CoreSentence> iterator = sentences.iterator();
        for (int i = 0; iterator.hasNext(); i++)
        {
            CoreSentence sentence = iterator.next();
            strSentences[i] = sentence.text();
            String sentiment = sentence.sentiment();
            sentenceSentiments[i] = stanfordNLPSentimentStringToSentimentInteger(sentiment);
        }
        analyzedTweet.setSentences(strSentences);
        analyzedTweet.setSentenceSentiments(sentenceSentiments);
        int overallSentiment = analyzeOverallTweetSentiment(analyzedTweet);
        System.out.println(overallSentiment);
        analyzedTweet.setOverallSentiment(overallSentiment);
        analyzedTweet.setAnalysisAuthorClassName(getAnalyzerClassName());
        return analyzedTweet;
    }

    private static final int VERY_NEGATIVE_HASHCODE = "very negative".hashCode();
    private static final int NEGATIVE_HASHCODE = "negative".hashCode();
    private static final int NEUTRAL_HASHCODE = "neutral".hashCode();
    private static final int POSITIVE_HASHCODE = "positive".hashCode();
    private static final int VERY_POSITIVE_HASHCODE = "very positive".hashCode();
    /**
     * Given a sentiment string generated by analyzing something in stanford nlp library
     * We output the correct integer that will be mapped to the correct sentiment with in this analzyedtweet class.
     *
     * @param sentiment - generated by nlp
     * @return Integer.MIN_VALUE if sentiment unsupported, other wise one of the sentiment constants
     */
    private static int stanfordNLPSentimentStringToSentimentInteger(String sentiment){
        int hashcode = sentiment.trim().toLowerCase().hashCode();
        if(hashcode == VERY_NEGATIVE_HASHCODE)
            return AnalyzedTweet.VERY_NEGATIVE_SENTIMENT;
        if(hashcode == NEGATIVE_HASHCODE)
            return AnalyzedTweet.NEGATIVE_SENTIMENT;
        if(hashcode == NEUTRAL_HASHCODE)
            return AnalyzedTweet.NEUTRAL_SENTIMENT;
        if(hashcode == POSITIVE_HASHCODE)
            return AnalyzedTweet.POSITIVE_SENTIMENT;
        if(hashcode == VERY_POSITIVE_HASHCODE)
            return AnalyzedTweet.VERY_POSITIVE_SENTIMENT;

        return Integer.MIN_VALUE;
    }

    @Override
    public List<AnalyzedTweet> analyzeSanitizedTweetsSentiment(List<? extends SanitizedTweet> sanitizedTweets) {
        List<AnalyzedTweet> analyzedTweets = new LinkedList<>();
        int numTweets = sanitizedTweets.size();
        for (int i = 0; i < numTweets; i++) {
            if(i % 500 == 0)
                System.out.printf("%s analyzing %d out of %d   %.2f%% done\n", getAnalyzerClassName(),i, numTweets, (((i * 1.0) / numTweets) * 100));
            SanitizedTweet sanitizedTweet = sanitizedTweets.get(i);
            AnalyzedTweet analyzedTweet = analyzeSanitizedTweetSentiment(sanitizedTweet);
            analyzedTweets.add(analyzedTweet);
        }
        return analyzedTweets;
    }

    /**
     * Stanford nlp only does sentiment on sentences so we must determine the over sentiment of the tweet based on the
     * sentiment of each sentence.
     *
     * @param sanitizedTweet
     * @return
     */
    public int analyzeOverallTweetSentiment(SanitizedTweet sanitizedTweet) {
        AnalyzedTweet analyzedTweet = null;

        boolean needToRunThroughPipeline = true;
        if(sanitizedTweet instanceof AnalyzedTweet)
        {
            analyzedTweet = (AnalyzedTweet) sanitizedTweet;

            //determine if have not  analyzed this with the pipeline
            if(analyzedTweet.getSentenceSentiments() != null){
                needToRunThroughPipeline = false;
            }
        }

        if(needToRunThroughPipeline) {
            analyzedTweet = analyzeSanitizedTweetSentiment(sanitizedTweet);
            System.out.println("running through pipeline again....");
        }

        int[] sentenceSentiments = analyzedTweet.getSentenceSentiments();
        int sent = 0;

        int totalPositive = 0;
        int totalVeryPositive = 0;
        int totalNegative = 0;
        int totalVeryNegative = 0;
        int totalNeutral = 0;
        for(int i = 0; i < sentenceSentiments.length; i++)
        {
            switch (sentenceSentiments[i])
            {
                case AnalyzedTweet.VERY_NEGATIVE_SENTIMENT :
                    totalVeryNegative++;
                    break;
                case AnalyzedTweet.NEGATIVE_SENTIMENT :
                    totalNegative++;
                    break;
                case AnalyzedTweet.NEUTRAL_SENTIMENT:
                    totalNeutral++;
                    break;
                case AnalyzedTweet.POSITIVE_SENTIMENT:
                    totalPositive++;
                    break;
                case AnalyzedTweet.VERY_POSITIVE_SENTIMENT:
                    totalVeryPositive++;
                    break;
            }
        }


        int sumNeg = (totalNegative + totalVeryNegative);
        int sumPos = (totalPositive + totalVeryPositive);
        if(1 <= sumPos)
        {
            sent = AnalyzedTweet.VERY_POSITIVE_SENTIMENT;//has only positive so strong postive
            if(1 <= totalNeutral)//has positive and neutral so semi positive
                sent = AnalyzedTweet.POSITIVE_SENTIMENT;
            if(1 <= sumNeg)//has positive and negative sentences so contradiction
                sent = AnalyzedTweet.UNDEFINED_SENTIMENT;
        }else if (1 <= sumNeg)
        {
            sent = AnalyzedTweet.VERY_NEGATIVE_SENTIMENT;
            if(1 <= totalNeutral)
                sent = AnalyzedTweet.NEGATIVE_SENTIMENT;
            if(1 <= sumPos)
                sent = AnalyzedTweet.UNDEFINED_SENTIMENT;
        }else {
            sent = AnalyzedTweet.NEUTRAL_SENTIMENT; //all neutral
        }

        return sent;
    }

    /**
     * Returns the name of the analyzed classname use this to sign each tweet you analyze with the name of your class.
     * i.e analyzedTweet.setAnalysisAuthorClassName(this.getClass().getName())
     *
     * @return
     */
    @Override
    public String getAnalyzerClassName() {
        return this.getClass().getName();
    }
}
